dalvik/vm/DvmDex.h

/*
 * Given a file descriptor for an open "optimized" DEX file, map it into
 * memory and parse the contents.
 *
 * On success, returns 0 and sets "*ppDvmDex" to a newly-allocated DvmDex.
 * On failure, returns a meaningful error code [currently just -1].
 */
int dvmDexFileOpenFromFd(int fd, DvmDex** ppDvmDex);

/*
 * Open a partial DEX file.  Only useful as part of the optimization process.
 */
int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex);

/*
 * Free a DvmDex structure, along with any associated structures.
 */
void dvmDexFileFree(DvmDex* pDvmDex);


/*
 * Change the 1- or 2-byte value at the specified address to a new value.  If
 * the location already has the new value, do nothing.
 *
 * This does not make any synchronization guarantees.  The caller must
 * ensure exclusivity vs. other callers.
 *
 * For the 2-byte call, the pointer should have 16-bit alignment.
 *
 * Returns "true" on success.
 */
bool dvmDexChangeDex1(DvmDex* pDvmDex, u1* addr, u1 newVal);
bool dvmDexChangeDex2(DvmDex* pDvmDex, u2* addr, u2 newVal);


//dalvik/libdex/SysUtil.h

/*
 * Copy a map.
 */
void sysCopyMap(MemMapping* dst, const MemMapping* src);

/*
 * Map a file (from fd's current offset) into a shared, read-only memory
 * segment that can be made writable.  (In some cases, such as when
 * mapping a file on a FAT filesystem, the result may be fully writable.)
 *
 * On success, "pMap" is filled in, and zero is returned.
 */
int sysMapFileInShmemWritableReadOnly(int fd, MemMapping* pMap);

/*
 * Map part of a file into a shared, read-only memory segment.
 *
 * On success, "pMap" is filled in, and zero is returned.
 */
int sysMapFileSegmentInShmem(int fd, off_t start, size_t length,
    MemMapping* pMap);

/*
 * Create a private anonymous mapping, useful for large allocations.
 *
 * On success, "pMap" is filled in, and zero is returned.
 */
int sysCreatePrivateMap(size_t length, MemMapping* pMap);

/*
 * Change the access rights on one or more pages.  If "wantReadWrite" is
 * zero, the pages will be made read-only; otherwise they will be read-write.
 *
 * Returns 0 on success.
 */
int sysChangeMapAccess(void* addr, size_t length, int wantReadWrite,
    MemMapping* pmap);

/*
 * Release the pages associated with a shared memory segment.
 *
 * This does not free "pMap"; it just releases the memory.
 */
void sysReleaseShmem(MemMapping* pMap);

/*
 * Write until all bytes have been written.
 *
 * Returns 0 on success, or an errno value on failure.
 */
int sysWriteFully(int fd, const void* buf, size_t count, const char* logMsg);

/*
 * Copy the given number of bytes from one fd to another. Returns
 * 0 on success, -1 on failure.
 */
int sysCopyFileToFile(int outFd, int inFd, size_t count);

//dalvik/libdex/DexFile.h

/*
 * Fix the byte ordering of all fields in the DEX file, and do
 * structural verification. This is only required for code that opens
 * "raw" DEX files, such as the DEX optimizer.
 *
 * Return 0 on success.
 */
int dexSwapAndVerify(u1* addr, int len);

/*
 * Detect the file type of the given memory buffer via magic number.
 * Call dexSwapAndVerify() on an unoptimized DEX file, do nothing
 * but return successfully on an optimized DEX file, and report an
 * error for all other cases.
 *
 * Return 0 on success.
 */
int dexSwapAndVerifyIfNecessary(u1* addr, int len);

/*
 * Check to see if the file magic and format version in the given
 * header are recognized as valid. Returns true if they are
 * acceptable.
 */
bool dexHasValidMagic(const DexHeader* pHeader);

/*
 * Compute DEX checksum.
 */
u4 dexComputeChecksum(const DexHeader* pHeader);

/*
 * Free a DexFile structure, along with any associated structures.
 */
void dexFileFree(DexFile* pDexFile);

/*
 * Create class lookup table.
 */
DexClassLookup* dexCreateClassLookup(DexFile* pDexFile);

/*
 * Find a class definition by descriptor.
 */
const DexClassDef* dexFindClass(const DexFile* pFile, const char* descriptor);

/*
 * Set up the basic raw data pointers of a DexFile. This function isn't
 * meant for general use.
 */
void dexFileSetupBasicPointers(DexFile* pDexFile, const u1* data);


//dalvik/libdex/DexClass.h

/* Read and verify the header of a class_data_item. This updates the
 * given data pointer to point past the end of the read data and
 * returns an "okay" flag (that is, false == failure). */
bool dexReadAndVerifyClassDataHeader(const u1** pData, const u1* pLimit,
        DexClassDataHeader *pHeader);

/* Read and verify an encoded_field. This updates the
 * given data pointer to point past the end of the read data and
 * returns an "okay" flag (that is, false == failure).
 *
 * The lastIndex value should be set to 0 before the first field in
 * a list is read. It is updated as fields are read and used in the
 * decode process.
 *
 * The verification done by this function is of the raw data format
 * only; it does not verify that access flags or indices
 * are valid. */
bool dexReadAndVerifyClassDataField(const u1** pData, const u1* pLimit,
        DexField* pField, u4* lastIndex);

/* Read and verify an encoded_method. This updates the
 * given data pointer to point past the end of the read data and
 * returns an "okay" flag (that is, false == failure).
 *
 * The lastIndex value should be set to 0 before the first method in
 * a list is read. It is updated as fields are read and used in the
 * decode process.
 *
 * The verification done by this function is of the raw data format
 * only; it does not verify that access flags, indices, or offsets
 * are valid. */
bool dexReadAndVerifyClassDataMethod(const u1** pData, const u1* pLimit,
        DexMethod* pMethod, u4* lastIndex);

/* Read, verify, and return an entire class_data_item. This updates
 * the given data pointer to point past the end of the read data. This
 * function allocates a single chunk of memory for the result, which
 * must subsequently be free()d. This function returns NULL if there
 * was trouble parsing the data. If this function is passed NULL, it
 * returns an initialized empty DexClassData structure.
 *
 * The verification done by this function is of the raw data format
 * only; it does not verify that access flags, indices, or offsets
 * are valid. */
DexClassData* dexReadAndVerifyClassData(const u1** pData, const u1* pLimit);



//dalvik/libdex/DexProto.h


/*
 * Get the type descriptor for the return type of the given prototype.
 */
const char* dexProtoGetReturnType(const DexProto* pProto);

/*
 * Get the parameter count of the given prototype.
 */
size_t dexProtoGetParameterCount(const DexProto* pProto);

/*
 * Compute the number of parameter words (u4 units) required by the
 * given prototype. For example, if the method takes (int, long) and
 * returns double, this would return 3 (one for the int, two for the
 * long, and the return type isn't relevant).
 */
int dexProtoComputeArgsSize(const DexProto* pProto);

/*
 * Compare the two prototypes. The two prototypes are compared
 * with the return type as the major order, then the first arguments,
 * then second, etc. If two prototypes are identical except that one
 * has extra arguments, then the shorter argument is considered the
 * earlier one in sort order (similar to strcmp()).
 */
int dexProtoCompare(const DexProto* pProto1, const DexProto* pProto2);

/*
 * Compare the two prototypes, ignoring return type. The two
 * prototypes are compared with the first argument as the major order,
 * then second, etc. If two prototypes are identical except that one
 * has extra arguments, then the shorter argument is considered the
 * earlier one in sort order (similar to strcmp()).
 */
int dexProtoCompareParameters(const DexProto* pProto1,
        const DexProto* pProto2);

/*
 * Compare a prototype and a string method descriptor. The comparison
 * is done as if the descriptor were converted to a prototype and compared
 * with dexProtoCompare().
 */
int dexProtoCompareToDescriptor(const DexProto* proto, const char* descriptor);

/*
 * Compare a prototype and a concatenation of type descriptors. The
 * comparison is done as if the descriptors were converted to a
 * prototype and compared with dexProtoCompareParameters().
 */
int dexProtoCompareToParameterDescriptors(const DexProto* proto,
        const char* descriptors);


/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java


CLASS LOADER:
BOOTSTRAP CLASSLOADER, il classloader di sistema , quello di default per JNI

Cose Fatte:
1 
	multi-thread
2
	comunicazione con il framework (PIPE)
3
	accesso alle classi dell'app target caricate in memoria, modulo per ottenere i valori decifrati dei campi


Problema:
1
	le classi dell app target caricate da dalvik, quindi non con il bootstrap classloader, non vengono trovate da FindClass di JNI. Con le funzioni di dalvik le trovo, pero' poi ho problemi ad invocare il relativo metodo. RISOLTO IN PARTE
2
	profiling  metodi
3
	Come definisco un modulo? 
4
	diverso comportamento se carico la lib  durante fork dello zygote o quando  il processo e' in esecuzione


Soluzioni
1
	Per le prove che ho fatto ottengo segfault quando chiamo dvmCallMethod,sia da thread native  che da quello dei comandi.
	Forse il problema che lo stack non e' preparato per quella chiamata.
	Se provassi a cercare la classe dal mondo Java?

2	
	Posso provare a fare hook su metodi nativi di Dalvik.

Devo guardare che classloader usa openDexNative di DexFile.
Xposed come risolve il problema del classloader?
Da java come ottengo il classLoader ? getClassLoader()  ?
Devo capire il flusso di Dalvik per interpretare il codice DEX.

Installo un apk, estraggo il dex, creo odex in dalvik-cache che viene mappato in memoria quando  l'app viene avviata.
Immagino che quando l'app viene avviata, tap sullo schermo  call su socket dello zygote fork() and specialize, ad un certo punto deve caricare le classi dell'applicazione. Dove?



"Thread-3136" prio=5 tid=34 NATIVE
  | group="main" sCount=1 dsCount=0 obj=0x41159970 self=0x32c188
  | sysTid=14755 nice=0 sched=0/0 cgrp=default handle=4528280
  | schedstat=( 0 0 0 ) utm=2 stm=0 core=0
  at libcore.io.Posix.recvfromBytes(Native Method)
  at libcore.io.Posix.recvfrom(Posix.java:131)
  at libcore.io.BlockGuardOs.recvfrom(BlockGuardOs.java:164)
  at libcore.io.IoBridge.recvfrom(IoBridge.java:503)
  at java.net.PlainSocketImpl.read(PlainSocketImpl.java:488)
  at java.net.PlainSocketImpl.access$000(PlainSocketImpl.java:46)
  at java.net.PlainSocketImpl$PlainSocketInputStream.read(PlainSocketImpl.java:240)
  at libcore.io.Streams.readSingleByte(Streams.java:41)
  at java.net.PlainSocketImpl$PlainSocketInputStream.read(PlainSocketImpl.java:236)
  at com.whatsapp.np.read(np.java:3)
  at com.whatsapp.uk.read(uk.java:5)
  at com.whatsapp.f7.a(f7.java:9)
  at com.whatsapp.j2.b(j2.java:145)
  at com.whatsapp.dx.a(dx.java:416)
  at com.whatsapp.messaging.c.run(c.java:16)
